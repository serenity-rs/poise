<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Asynchronous TLS/SSL streams for Tokio using Rustls."><title>tokio_rustls - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tokio_rustls" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-nightly (e92993dbb 2024-10-18)" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../tokio_rustls/index.html">tokio_<wbr>rustls</a><span class="version">0.25.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#why-do-i-need-to-call-poll_flush" title="Why do I need to call `poll_flush`?">Why do I need to call <code>poll_flush</code>?</a><ul><li><a href="#why-dont-we-write-during-poll_read" title="Why don’t we write during `poll_read`?">Why don’t we write during <code>poll_read</code>?</a></li><li><a href="#why-cant-we-handle-it-like-native-tls" title="Why can’t we handle it like `native-tls`?">Why can’t we handle it like <code>native-tls</code>?</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>tokio_rustls</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/tokio_rustls/lib.rs.html#1-558">source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Asynchronous TLS/SSL streams for Tokio using <a href="https://github.com/rustls/rustls">Rustls</a>.</p>
<h2 id="why-do-i-need-to-call-poll_flush"><a class="doc-anchor" href="#why-do-i-need-to-call-poll_flush">§</a>Why do I need to call <code>poll_flush</code>?</h2>
<p>Most TLS implementations will have an internal buffer to improve throughput,
and rustls is no exception.</p>
<p>When we write data to <code>TlsStream</code>, we always write rustls buffer first,
then take out rustls encrypted data packet, and write it to data channel (like TcpStream).
When data channel is pending, some data may remain in rustls buffer.</p>
<p><code>tokio-rustls</code> To keep it simple and correct, <a href="enum.TlsStream.html" title="enum tokio_rustls::TlsStream">TlsStream</a> will behave like <code>BufWriter</code>.
For <code>TlsStream&lt;TcpStream&gt;</code>, this means that data written by <code>poll_write</code> is not guaranteed to be written to <code>TcpStream</code>.
You must call <code>poll_flush</code> to ensure that it is written to <code>TcpStream</code>.</p>
<p>You should call <code>poll_flush</code> at the appropriate time,
such as when a period of <code>poll_write</code> write is complete and there is no more data to write.</p>
<h3 id="why-dont-we-write-during-poll_read"><a class="doc-anchor" href="#why-dont-we-write-during-poll_read">§</a>Why don’t we write during <code>poll_read</code>?</h3>
<p>We did this in the early days of <code>tokio-rustls</code>, but it caused some bugs.
We can solve these bugs through some solutions, but this will cause performance degradation (reverse false wakeup).</p>
<p>And reverse write will also prevent us implement full duplex in the future.</p>
<p>see <a href="https://github.com/tokio-rs/tls/issues/40">https://github.com/tokio-rs/tls/issues/40</a></p>
<h3 id="why-cant-we-handle-it-like-native-tls"><a class="doc-anchor" href="#why-cant-we-handle-it-like-native-tls">§</a>Why can’t we handle it like <code>native-tls</code>?</h3>
<p>When data channel returns to pending, <code>native-tls</code> will falsely report the number of bytes it consumes.
This means that if data written by <code>poll_write</code> is not actually written to data channel, it will not return <code>Ready</code>.
Thus avoiding the call of <code>poll_flush</code>.</p>
<p>but which does not conform to convention of <code>AsyncWrite</code> trait.
This means that if you give inconsistent data in two <code>poll_write</code>, it may cause unexpected behavior.</p>
<p>see <a href="https://github.com/tokio-rs/tls/issues/41">https://github.com/tokio-rs/tls/issues/41</a></p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.rustls"><code>pub use <a class="mod" href="../rustls/index.html" title="mod rustls">rustls</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="client/index.html" title="mod tokio_rustls::client">client</a></div></li><li><div class="item-name"><a class="mod" href="server/index.html" title="mod tokio_rustls::server">server</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Accept.html" title="struct tokio_rustls::Accept">Accept</a></div><div class="desc docblock-short">Future returned from <code>TlsAcceptor::accept</code> which will resolve
once the accept handshake has finished.</div></li><li><div class="item-name"><a class="struct" href="struct.Connect.html" title="struct tokio_rustls::Connect">Connect</a></div><div class="desc docblock-short">Future returned from <code>TlsConnector::connect</code> which will resolve
once the connection handshake has finished.</div></li><li><div class="item-name"><a class="struct" href="struct.FallibleAccept.html" title="struct tokio_rustls::FallibleAccept">Fallible<wbr>Accept</a></div><div class="desc docblock-short">Like <a href="struct.Accept.html" title="struct tokio_rustls::Accept">Accept</a>, but returns <code>IO</code> on failure.</div></li><li><div class="item-name"><a class="struct" href="struct.FallibleConnect.html" title="struct tokio_rustls::FallibleConnect">Fallible<wbr>Connect</a></div><div class="desc docblock-short">Like <a href="struct.Connect.html" title="struct tokio_rustls::Connect">Connect</a>, but returns <code>IO</code> on failure.</div></li><li><div class="item-name"><a class="struct" href="struct.LazyConfigAcceptor.html" title="struct tokio_rustls::LazyConfigAcceptor">Lazy<wbr>Config<wbr>Acceptor</a></div></li><li><div class="item-name"><a class="struct" href="struct.StartHandshake.html" title="struct tokio_rustls::StartHandshake">Start<wbr>Handshake</a></div></li><li><div class="item-name"><a class="struct" href="struct.TlsAcceptor.html" title="struct tokio_rustls::TlsAcceptor">TlsAcceptor</a></div><div class="desc docblock-short">A wrapper around a <code>rustls::ServerConfig</code>, providing an async <code>accept</code> method.</div></li><li><div class="item-name"><a class="struct" href="struct.TlsConnector.html" title="struct tokio_rustls::TlsConnector">TlsConnector</a></div><div class="desc docblock-short">A wrapper around a <code>rustls::ClientConfig</code>, providing an async <code>connect</code> method.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.TlsStream.html" title="enum tokio_rustls::TlsStream">TlsStream</a></div><div class="desc docblock-short">Unified TLS stream type</div></li></ul></section></div></main></body></html>