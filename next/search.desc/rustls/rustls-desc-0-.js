searchState.loadedDescShard("rustls", 0, "Rustls - a modern TLS library\nA list of all the protocol versions supported by rustls.\nSecrets for the AES_128_GCM AEAD algorithm\nSecrets for the AES_256_GCM AEAD algorithm\nThe <code>AlertDescription</code> TLS protocol enum.  Values in this …\nWe received a fatal alert.  This means the peer is unhappy.\nThe certificate is valid, but the handshake is rejected …\nThe certificate is not correctly encoded.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nA certificate is not correctly signed by the key of its …\nThe CRL had a bad, or unsupported signature from its …\nThe ways in which a certificate revocation list (CRL) can …\nThe ways in which certificate validators can express …\nSecrets for the CHACHA20_POLY1305 AEAD algorithm\nThe <code>CipherSuite</code> TLS protocol enum.  Values in this enum …\nA client initiates the connection.\nA client connection\nConnection state common to both client and server …\nA builder for <code>ServerConfig</code> or <code>ClientConfig</code> values.\nHelper trait to abstract <code>ConfigBuilder</code> over building a …\nA client or server connection.\nInterface shared by client and server connections.\nSecrets used to encrypt/decrypt data in a TLS session.\nThe <code>ContentType</code> TLS protocol enum.  Values in this enum …\nThe version configuration that an application should use …\nWe couldn’t decrypt a message.  This is invariably fatal.\nThis type combines a <code>SignatureScheme</code> and a signature …\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nThe current time is after the <code>notAfter</code> time in the …\nSecrets for transmitting/receiving data over a TLS session.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nThis function doesn’t work until the TLS handshake is …\nAn advertised message was larger then expected.\nThe <code>HandshakeType</code> TLS protocol enum.  Values in this enum …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nThe peer sent us a syntactically incorrect …\nContext was incorrectly attached to a certificate request …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nA peer sent an invalid certificate status type\nAn unknown content type was encountered during message …\nThe CRL contained an invalid CRL number.\nA peer’s DH params could not be decoded\nA message was zero-length when its record kind forbids it.\nA peer sent an unexpected key update request.\nA corrupt TLS message payload that resulted in an error.\nThe peer sent us a TLS message with invalid contents.\nThe certificate is being used for a different purpose than …\nThe CRL contained a revoked certificate with an invalid …\nA peer’s server name could not be decoded\nValues of this structure are returned from …\nThe CRL issuer does not specify the cRLSign key usage.\nThis trait represents the ability to do something useful …\n<code>KeyLog</code> implementation that opens a file whose name is …\nA TLS message payload was larger then allowed by the …\nMessage is shorter than the expected length\nMissing data for the named handshake payload value\nA peer did not advertise its supported key exchange groups.\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nKeyLog that does exactly nothing.\nA peer sent an empty list of signature schemes\nThe subject names in an end-entity certificate do not …\nThe current time is before the <code>notBefore</code> time in the …\nAny other error.\nAny other error.\nThe CRL is invalid for some other reason.\nAny other error that cannot be expressed by a more …\nThe CRL is not correctly encoded.\nThe set of cases where we failed to make a connection …\nThe peer doesn’t support a protocol version/feature we …\nThe set of cases where we failed to make a connection …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nThe <code>ProtocolVersion</code> TLS protocol enum.  Values in this …\nA structure that implements <code>std::io::Read</code> for reading …\nThe certificate has been revoked.\nA container for root certificates able to provide a …\nA server waits for a client to connect.\nA server connection\nSide of the connection.\nData specific to the peer’s side (client or server).\nThe <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this …\nThe <code>SignatureScheme</code> TLS protocol enum.  Values in this …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nA cipher suite supported by rustls.\nA TLS protocol version supported by rustls.\nA TLS 1.2 cipher suite\nA TLS 1.2 cipher suite supported by rustls.\nA TLS 1.3 cipher suite\nA TLS 1.3 cipher suite supported by rustls.\nTrailing data found for the named handshake payload value\nA peer sent an unexpected message type.\nThe certificate contains an extension marked critical, but …\nThe certificate chain is not issued by a known root …\nAn unknown TLS protocol was encountered during message …\nThe certificate’s revocation status could not be …\nA peer sent a non-null compression method.\nThe CRL, or a revoked certificate in the CRL, contained an …\nThe CRL is not a v2 X.509 CRL.\nA peer sent an unknown elliptic curve type.\nThe CRL is an unsupported delta CRL, containing only …\nThe CRL is an unsupported indirect CRL, containing revoked …\nA peer sent an unsupported key exchange algorithm.\nThe certificate verifier doesn’t support the given type …\nThe CRL contained a revoked certificate with an …\nConfig builder state where the caller must supply a …\nConfig builder state where the caller must supply TLS …\nA structure that implements <code>std::io::Write</code> for writing …\nAdd a single DER-encoded certificate to the store.\nParse the given DER-encoded certificates and add all that …\nHow to produce a <code>MessageDecrypter</code> or <code>MessageEncrypter</code> from …\nHow to produce a MessageDecrypter or MessageEncrypter from …\nRetrieves the protocol agreed with the peer via ALPN.\nCan a session using suite self resume from suite prev?\nItems for use in a client.\nCommon cipher suite fields.\nCommon cipher suite fields.\nThis function uses <code>io</code> to complete any outstanding IO for …\nThis function uses <code>io</code> to complete any outstanding IO for …\nOur TLS connection\nOur connection\nCrypto provider interface.\nAccess configuration options whose use is dangerous and …\nExtract secrets, so they can be used when configuring …\nExtract secrets, so they can be used when configuring …\nMake a new, empty <code>RootCertStore</code>.\nDerives key material from the agreed connection secrets.\nDerives key material from the agreed connection secrets.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable reference to the underlying socket\nGet a reference to the underlying socket\nHow to complete HKDF with the suite’s hash function.\nInternal classes that are used in integration tests. The …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtract the <code>conn</code> and <code>sock</code> parts from the <code>StreamOwned</code>\nReturn true if there are no certificates.\nReturns true if the connection is currently performing the …\nHow to exchange/agree keys.\nSay how many certificates are in the container.\nLog the given <code>secret</code>.  <code>client_random</code> is provided for …\nThis is the rustls manual.\nRetrieves the ciphersuite agreed with the peer.\nMakes a new <code>KeyLogFile</code>.  The environment variable is …\nMake a new Stream using the Connection <code>conn</code> and …\nMake a new StreamOwned taking the Connection <code>conn</code> and …\nRetrieves the certificate chain used by the peer to …\nTrue if the peer has sent us a close_notify alert.  This is\nRe-exports the contents of the rustls-pki-types crate for …\nHow many plaintext bytes could be obtained via …\nHow to compute the TLS1.2 PRF for the suite’s hash …\nProcesses any new packets read by a previous call to …\nProcesses any new packets read by a previous call to …\nRetrieves the protocol version agreed with the peer.\nAPIs for implementing QUIC TLS\nHow to create QUIC header and record protection algorithms …\nObtain plaintext data received from the peer over this TLS …\nRead TLS content from <code>rd</code> into the internal buffer.\nRead TLS content from <code>rd</code>.\nReturns an object that allows reading plaintext.\nReturns an object that allows reading plaintext.\nResolve the set of supported <code>SignatureScheme</code>s from the …\nThe list of roots.\nsequence number and secrets for the “rx” (receive) …\nThe <code>SignatureScheme</code> used to produce the signature.\nQueues a close_notify warning alert to be sent in the next …\nItems for use in a server.\nSets a limit on the internal buffers used to buffer unsent …\nMessage signing interfaces.\nHow to sign messages for authentication.\nGet the signature.\nThe underlying transport, like a socket\nThe underlying transport, like a socket\nReturn the DER encoded <code>DistinguishedName</code> of each trust …\nThe cipher suite’s identifier\nAPIs for implementing TLS tickets\nReturn the inner <code>Tls13CipherSuite</code> for this suite, if it is …\nHow many bytes could be written by <code>Connection::write_tls</code> …\nsequence number and secrets for the “tx” (transmit) …\nReturn true if this suite is usable for a key only …\nAll defined protocol versions appear in this module.\nReturn supported protocol version for the cipher suite.\nThe TLS enumeration naming this version.\nReturns true if the caller should call <code>Connection::read_tls</code>…\nReturns true if the caller should call …\nIndicates whether the secret with label <code>label</code> will be …\nIndicates whether the secret with label <code>label</code> will be …\nSets a custom <code>ResolvesServerCert</code>.\nSets a single certificate chain and matching private key …\nSets a custom <code>ResolvesClientCert</code>.\nChoose how to verify client certificates.\nDo not support client auth.\nDisable client authentication.\nUse a specific set of protocol versions.\nChoose how to verify server certificates.\nAccept the default protocol versions: both TLS1.2 and …\nSets a single certificate chain and matching private key.  …\nSets a single certificate chain, matching private key and …\nChoose how to verify server certificates using a webpki …\nSend the plaintext <code>buf</code> to the peer, encrypting and …\nWrites TLS messages to <code>wr</code>.\nWrites TLS messages to <code>wr</code>.\nReturns an object that allows writing plaintext.\nReturns an object that allows writing plaintext.\nInitialization vector\nInitialization vector\nInitialization vector\nAEAD Key\nAEAD Key\nAEAD Key\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nCommon configuration for (typically) all connections made …\nThis represents a single TLS client connection.\nState associated with a client connection.\nAn implementer of <code>ClientSessionStore</code> that stores everything\nA trait for the ability to store client session data, so …\nDisable 1.2 resumption.\nA provided CRL could not be parsed.\nNo root trust anchors were provided.\nA trait for the ability to choose a certificate chain and …\nConfiguration for how/when a client is allowed to resume a …\nA builder for configuring a <code>webpki</code> server certificate …\nSupport 1.2 resumption using session ids only.\nSupport 1.2 resumption using session ids or RFC 5077 …\nWhat mechanisms to support for resuming a TLS 1.2 session.\nAn error that can occur when building a certificate …\nA config builder state where the caller needs to supply …\nDefault <code>ServerCertVerifier</code>, see the trait impl for more …\nStub that implements io::Write and dispatches to …\nAllow unknown certificate revocation status when using …\nWhich ALPN protocols we include in our client hello. If …\nBuild a server certificate verifier, allowing control over …\nCreate a builder for the <code>webpki</code> server certificate …\nCreate a builder for a client configuration with the …\nCreate a builder for a client configuration with the …\nCreate a builder for the <code>webpki</code> server certificate …\nCreate a builder for a client configuration with a …\nHow many bytes you may send.  Writes will become short …\nHow to decide what client auth certificate/keys to use.\nDangerous configuration that should be audited and used …\nAccess configuration options whose use is dangerous and …\nExtract secrets, so they can be used when configuring …\nCreate an in-memory session store resumption with up to …\nDisable all use of session resumption.\nReturns an <code>io::Write</code> implementer you can write bytes to to …\nWhether to send data on the first flight (“early data”…\nAllows traffic secrets to be extracted after the handshake,\nWhether to send the Server Name Indication (SNI) extension …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn true if any certificates at all are available.\nCreate a new <code>Resumption</code> that stores data for the given …\nRemember a TLS1.3 ticket that might be retrieved later …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns True if the server signalled it will process early …\nHow to output key material for debugging.  The default …\nThis should return the value most recently passed to …\nThe maximum size of plaintext input to be emitted in a …\nMake a new ClientConnection.  <code>config</code> controls how we …\nMake a new ClientSessionMemoryCache.  <code>size</code> is the maximum …\nOnly check the end entity certificate revocation status …\nRemove and forget any saved TLS1.2 session for <code>server_name</code>.\nResolve a client certificate chain/private key to use as …\nHow and when the client can resume a previous session.\nRemember what <code>NamedGroup</code> the given server chose.\nRemember a TLS1.2 session.\nUse a custom <code>ClientSessionStore</code> implementation to store …\nReturn a TLS1.3 ticket previously provided to …\nConfigure whether TLS 1.2 sessions may be resumed, and by …\nGet the most recently saved TLS1.2 session for <code>server_name</code> …\nWill verify the certificate is valid in the following ways:\nVerify that the end-entity certificate <code>end_entity</code> is a …\nVerify that the <code>end_entity</code> has a name or alternative name …\nVerify the revocation state of presented client …\nAccessor for dangerous configuration options.\nAccessor for dangerous configuration options.\nZero-sized marker type representing verification of a …\nZero-sized marker type representing verification of a …\nSomething that can verify a server certificate chain, and …\nMake a <code>HandshakeSignatureValid</code>\nMake a <code>ServerCertVerified</code>\nThe underlying ClientConfigBuilder\nThe underlying ClientConfig\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOverrides the default <code>ServerCertVerifier</code> with something …\nReturn the list of SignatureSchemes that this verifier …\nVerify the end-entity certificate <code>end_entity</code> is valid for …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nSet a custom certificate verifier.\nAn in-progress key exchange originating from a …\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nControls core cryptography used by rustls.\nKey exchange performed via elliptic curve Diffie-Hellman.\nRandom material generation failed.\nDescribes supported key exchange mechanisms.\nA mechanism for loading private SigningKeys from …\nA source of cryptographically secure randomness.\nThe result from <code>ActiveKeyExchange::complete</code>.\nA supported key exchange group.\nDescribes which <code>webpki</code> signature verification algorithms …\nA list of all supported signature verification algorithms.\nTLS message encryption/decryption interfaces.\nList of supported ciphersuites, in preference order – …\nCompletes the key exchange, given the peer’s public key.\nNumber of messages that can be safely encrypted with a …\nFill the given buffer with random bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the group being used.\nHashing interfaces.\nWhich hash function the suite uses.\nHMAC interfaces.\nNumber of messages that can be safely decrypted with a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProvider for loading private SigningKeys from PrivateKeyDer…\nList of supported key exchange groups, in preference order …\nDecode and validate a private signing key from <code>key_der</code>.\nA mapping from TLS <code>SignatureScheme</code>s to matching webpki …\nNamed group the SupportedKxGroup operates in.\nReturn the public key being used.\n<em>ring</em> based CryptoProvider.\nReturns the shared secret as a slice of bytes.\nSource of cryptographically secure random numbers.\nList of signature verification algorithms for use with …\nStart a key exchange.\nThe TLS enumeration naming this cipher suite.\nReturn all the <code>scheme</code> items in <code>mapping</code>, maintaining order.\nCryptography specific to TLS1.2.\nCryptography specific to TLS1.3.\nVerify a message signature using the <code>cert</code> public key and …\nVerify a message signature using the <code>cert</code> public key and …\nA key for an AEAD algorithm.\nA TLS frame, named TLSPlaintext in the standard.\nA write or read IV.\nHow a TLS1.2 <code>key_block</code> is partitioned.\nMaximum on-wire message size.\nObjects with this trait can decrypt TLS messages.\nObjects with this trait can encrypt TLS messages.\nSize of TLS nonces (incorrectly termed “IV” in …\nA nonce.  This is unique for all messages on a connection.\nA TLS frame, named TLSPlaintext in the standard.\nA decrypted TLS frame\nFactory trait for building <code>MessageEncrypter</code> and …\nFactory trait for building <code>MessageEncrypter</code> and …\nAn error indicating that the AEAD algorithm does not …\nCreate a new <code>Iv</code> from a byte slice, of precisely <code>NONCE_LEN</code> …\nDecrypt the given TLS message <code>msg</code>, using the sequence …\nBuild a <code>MessageDecrypter</code> for the given key/iv.\nBuild a <code>MessageDecrypter</code> for the given key/iv.\nHow long keys are.\nEncrypt the given TLS message <code>msg</code>, using the sequence …\nReturn the length of the ciphertext that results from …\nBuild a <code>MessageEncrypter</code> for the given key/iv.\nBuild a <code>MessageEncrypter</code> for the given key/iv and extra …\nThis is a non-standard extension which extends the key …\nConvert the key material from <code>key</code>/<code>iv</code>, into a …\nConvert the key material from <code>key</code>/<code>iv</code>, into a …\nHow long the fixed part of the ‘IV’ is.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce conversion into a plaintext message.\nFor TLS1.3 (only), checks the length msg.payload is valid …\nReturn a <code>KeyBlockShape</code> that defines how large the <code>key_block</code>…\nThe length of key in bytes required by <code>encrypter()</code> and …\nReturns a TLS1.2 <code>additional_data</code> encoding.\nReturns a TLS1.3 <code>additional_data</code> encoding.\nCombine an <code>Iv</code> and sequence number to produce a unique …\nConstruct a new <code>OpaqueMessage</code> from constituent fields.\nCreate a new <code>Iv</code> from a byte array, of precisely <code>NONCE_LEN</code> …\nAccess the message payload as a slice.\nAccess the message payload as a mutable <code>Vec&lt;u8&gt;</code>.\n<code>MessageError</code> allows callers to distinguish between valid …\nHow to incrementally compute a hash.\nDescribes a single cryptographic hash function.\nThe <code>HashAlgorithm</code> TLS protocol enum.  Values in this enum …\nMaximum supported hash output size: supports up to SHA512.\nA hash output, stored as a value.\nWhich hash function this is, eg, <code>HashAlgorithm::SHA256</code>.\nTerminate and finish the computation, returning the …\nFork the computation, producing another context that has …\nFinish the computation, returning the resulting output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the output of this hash function with input <code>data</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuild a <code>hash::Output</code> from a slice of no more than …\nThe length in bytes of this hash function’s output.\nStart an incremental hash computation.\nAdd <code>data</code> to computation.\nA concrete HMAC implementation, for a single cryptographic …\nA HMAC key that is ready for use.\nMaximum supported HMAC tag size: supports up to SHA512.\nA HMAC tag, stored as a value.\nReturns the argument unchanged.\nGive the length of the underlying hash function.  In …\nCalls <code>U::from(self)</code>.\nBuild a tag by copying a byte slice.\nCalculates a tag over <code>data</code> – a slice of byte slices.\nCalculates a tag over the concatenation of <code>first</code>, the …\nReturns the length of the tag returned by a computation …\nPrepare to use <code>key</code> as a HMAC key.\nA list of all the cipher suites supported by the rustls …\nA list of all the key exchange groups supported by rustls.\nThe cipher suite configuration that an application should …\nA concrete, safe ticket creation mechanism.\nAll defined cipher suites supported by <em>ring</em> appear in this …\nA <code>CryptoProvider</code> backed by the <em>ring</em> crate.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAll defined key exchange groups supported by <em>ring</em> appear …\nMake the recommended Ticketer.  This produces tickets with …\nUsing software keys for authentication.\nThe TLS1.3 ciphersuite TLS_AES_128_GCM_SHA256\nThe TLS1.3 ciphersuite TLS_AES_256_GCM_SHA384\nThe TLS1.3 ciphersuite TLS_CHACHA20_POLY1305_SHA256\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nEphemeral ECDH on secp256r1 (aka NIST-P256)\nEphemeral ECDH on secp384r1 (aka NIST-P384)\nEphemeral ECDH on curve25519 (see RFC7748)\nParse <code>der</code> as any ECDSA key type, returning the first which …\nParse <code>der</code> as any EdDSA key type, returning the first which …\nParse <code>der</code> as any supported key encoding/type, returning …\nAn instantiation of the TLS1.2 PRF with a specific, …\nImplements <code>Prf</code> using a <code>hmac::Hmac</code>.\nComputes <code>PRF(secret, label, seed)</code> using the secret from a …\nComputes <code>PRF(secret, label, seed)</code>, writing the result into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA HKDF implementation oriented to the needs of TLS1.3.\nImplementation of <code>HKDF-Expand</code> with an implicitly stored …\nImplementation of <code>HkdfExpander</code> via <code>hmac::Key</code>.\nImplementation of <code>Hkdf</code> (and thence <code>HkdfExpander</code>) via …\nMaximum supported HMAC tag size: supports up to SHA512.\nOutput key material from HKDF, as a value type.\nAn error type used for <code>HkdfExpander::expand_slice</code> when the …\n<code>HKDF-Expand(PRK, info, L)</code> to construct any type from a …\n<code>HKDF-Expand(PRK, info, L=HashLen)</code> returned as a value.\n<code>HKDF-Expand(PRK, info, L)</code> into a slice.\nBuild a <code>HkdfExpander</code> using <code>okm</code> as the secret PRK.\n<code>HKDF-Extract(salt, shared_secret)</code> where <code>shared_secret</code> is …\n<code>HKDF-Extract(salt, secret)</code>\n<code>HKDF-Extract(salt, 0_HashLen)</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn what <code>HashLen</code> is for this instance.\nSigns <code>message</code> using <code>key</code> viewed as a HMAC key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuild a single OKM block by copying a byte slice.\nLow-level TLS message parsing and encoding functions.\nAn externally length’d payload\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait for implementing encoding and decoding functionality …\nWrapper over a slice of bytes that allows reading chunks …\nUsed to check whether the reader has any content left …\nFunction for encoding itself by appending itself to the …\nReturns the argument unchanged.\nConvenience function for encoding the implementation into …\nConvenience function for encoding the implementation into …\nCreates a new Reader of the provided <code>bytes</code> slice with the …\nCalls <code>U::from(self)</code>.\nReturns the number of bytes that are still able to be read …\nFunction for decoding itself from the provided reader will …\nFunction for wrapping a call to the read function in a …\nFunction for wrapping a call to the read function in a …\nBorrows a slice of all the remaining bytes that appear …\nAttempts to create a new Reader on a sub section of this …\nAttempts to borrow a slice of bytes from the current …\nReturns the cursor position which is also the number of …\nThis deframer works to reconstruct TLS messages from a …\nBorrows the initialized contents of this buffer and tracks …\nDiscard <code>taken</code> bytes from the start of our buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if there are messages for the caller to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn any decrypted messages that the deframer has been …\nRead some bytes from <code>rd</code>, and add them to our internal …\nThe <code>AlertLevel</code> TLS protocol enum.  Values in this enum are …\nThe <code>Compression</code> TLS protocol enum.  Values in this enum …\nThe Encrypted Client Hello protocol version (<code>EchVersion</code>).\nThe Authenticated Encryption with Associated Data (<code>Aead</code>) …\nThe Key Derivation Function (<code>Kdf</code>) type for HPKE operations.\nThe Key Encapsulation Mechanism (<code>Kem</code>) type for HPKE …\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the Message <code>msg</code> and re-fragment it into new messages …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSet the maximum fragment size that will be produced.\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>DistinguishedName</code> after prepending its outer …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA message with decoded payload\nA TLS frame, named TLSPlaintext in the standard.\nA decrypted TLS frame\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRecord layer that tracks decryption and encryption keys.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new record layer with no keys.\nThis section discusses vulnerabilities in other TLS …\nThis section discusses vulnerabilities and design errors …\nThis section collects together goal-oriented documentation.\nThis section documents rustls itself: what protocol …\nThis section provides rationale for the defaults in rustls.\nFailure to parse an IP address\nA DER encoding of the PKIX AlgorithmIdentifier type:\nA DER-encoded X.509 certificate; as specified in RFC 5280\nA Certificate Revocation List; as specified in RFC 5280\nA Certificate Signing Request; as specified in RFC 2986\nDER-encoded data, either owned or borrowed\nA type which encapsulates a string (borrowed or owned) …\nThe server is identified by a DNS name.  The name is sent …\nA TLS-encoded Encrypted Client Hello (ECH) configuration …\nThe provided input could not be parsed because it is not a …\nA detail-less error when a signature is not valid.\n<code>no_std</code> implementation of <code>std::net::IpAddr</code>.\nThe server is identified by an IP address. SNI is not done.\n<code>no_std</code> implementation of <code>std::net::Ipv4Addr</code>.\n<code>no_std</code> implementation of <code>std::net::Ipv6Addr</code>.\nAn RSA private key\nA PKCS#8 private key\nA DER-encoded X.509 private key, in one of several formats\nA DER-encoded plaintext RSA private key; as specified in …\nA DER-encoded plaintext private key; as specified in …\nA Sec1-encoded plaintext private key; as specified in RFC …\nA Sec1 private key\nEncodes ways a client can know the expected name of the …\nAn abstract signature verification algorithm.\nA DER-encoded SubjectPublicKeyInfo (SPKI), as specified in …\nA DER-encoded SubjectPublicKeyInfo (SPKI), as specified in …\nA trust anchor (a.k.a. root CA)\nA timestamp, tracking the number of non-leap seconds since …\nAn Ipv4 address.\nAn Ipv6 address.\nNumber of seconds since the Unix epoch\nProduce a borrowed <code>DnsName</code> from this owned <code>DnsName</code>.\nClone the private key to a <code>&#39;static</code> value\nClone the private key to a <code>&#39;static</code> value\nClone the private key to a <code>&#39;static</code> value\nClone the private key to a <code>&#39;static</code> value\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMakes a new <code>AlgorithmIdentifier</code> from a static octet slice.\nA const constructor to create a <code>Der</code> from a borrowed slice\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts this certificate into its owned variant, …\nConverts this SubjectPublicKeyInfo into its owned variant, …\nConverts this config into its owned variant, unfreezing …\nValue of DER-encoded <code>NameConstraints</code>, containing name …\nThe current time, as a <code>UnixTime</code>\nReturn the <code>AlgorithmIdentifier</code> that must equal a public key…\nYield the DER-encoded bytes of the private key\nYield the DER-encoded bytes of the private key\nYield the DER-encoded bytes of the private key\nYield the DER-encoded bytes of the private key\nReturn the <code>AlgorithmIdentifier</code> that must equal the …\nConvert a <code>Duration</code> since the start of 1970 to a <code>UnixTime</code>\nValue of the <code>subject</code> field of the trust anchor\nValue of the <code>subjectPublicKeyInfo</code> field of the trust anchor\nCopy this object to produce an owned <code>DnsName</code>, smashing the …\nProduce an owned <code>ServerName</code> from this (potentially …\nProduce an owned <code>DnsName</code> from this (potentially borrowed) …\nYield a <code>&#39;static</code> lifetime of the <code>TrustAnchor</code> by allocating …\nReturn the string representation of this <code>ServerName</code>.\nVerify a signature.\nHow a <code>Tls13CipherSuite</code> generates <code>PacketKey</code>s and …\nA client connection\nA QUIC client connection.\nA QUIC client or server connection.\nA shared interface for QUIC connections.\nKeys used to communicate in a single direction\nKeys for the handshake space\nA QUIC header protection key\nKey material for use in QUIC packet spaces\nComplete set of keys used to communicate with the peer\nKeys for 1-RTT data\nKeys to encrypt or decrypt the payload of a packet\nPacket protection keys for bidirectional 1-RTT …\nSecrets used to encrypt/decrypt traffic\nA server connection\nA QUIC server connection.\nAuthentication tag from an AEAD seal operation.\nFirst stable RFC\nDraft versions 29, 30, 31 and 32\nAnti-ossification variant of V1\nQUIC protocol version\nThe length in bytes of keys for this Algorithm.\nEmit the TLS description code of a fatal alert, if one has …\nEmit the TLS description code of a fatal alert, if one has …\nRemoves QUIC Header Protection.\nDecrypt a QUIC packet\nAdds QUIC Header Protection.\nEncrypt a QUIC packet\nDerives key material from the agreed connection secrets.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEncrypts or decrypts a packet’s headers\nProduce a <code>HeaderProtectionKey</code> encrypter/decrypter for this …\nConstruct keys for use with initial packets\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns True if the server signalled it will process early …\nEncrypts outgoing packets\nEncrypts outgoing packets\nMake a new QUIC ClientConnection.\nMake a new QUIC ServerConnection.\nDerive the next set of packet keys\nEncrypts or decrypts the payload of a packet\nProduce a <code>PacketKey</code> encrypter/decrypter for this suite.\nReturn the TLS-encoded transport parameters for the session…\nReturn the TLS-encoded transport parameters for the session…\nConsume unencrypted TLS handshake data.\nConsume unencrypted TLS handshake data.\nExplicitly discard early data, notifying the client\nDecrypts incoming packets\nDecrypts incoming packets\nExpected sample length for the key’s algorithm\nRetrieves the server name, if any, used to select the …\nTag length for the underlying AEAD algorithm\nEmit unencrypted TLS handshake data.\nEmit unencrypted TLS handshake data.\nCompute the keys for encrypting/decrypting 0-RTT packets, …\nCompute the keys for encrypting/decrypting 0-RTT packets, …\nHeader and packet keys for the handshake space\nHeader and packet keys for 1-RTT data\nSecrets to derive updated keys from\nRepresents a <code>ClientHello</code> message received through the …\nHandle a server-side connection before configuration is …\nA builder for configuring a <code>webpki</code> client certificate …\nA struct representing the received Client Hello\nA provided CRL could not be parsed.\nTurns off client authentication. In contrast to using …\nNo root trust anchors were provided.\nSomething which never stores sessions.\nWrapper around internal representation of a parsed …\nA trait for the ability to encrypt and decrypt tickets.\nAllows reading of early data in resumed TLS1.3 connections.\nHow to choose a certificate chain and signing key for use …\nSomething that resolves do different cert chains/keys based\nCommon configuration for a set of server sessions.\nThis represents a single TLS server connection.\nState associated with a server connection.\nAn implementer of <code>StoresServerSessions</code> that stores …\nA trait for the ability to store server session data.\nAn error that can occur when building a certificate …\nA config builder state where the caller must supply how to …\nA client certificate verifier that uses the <code>webpki</code> crate …\nCheck if a <code>ClientHello</code> message has been received.\nAdd a new <code>sign::CertifiedKey</code> to be used for the given SNI …\nAdd additional <code>DistinguishedName</code>s to the list of trust …\nAllow unauthenticated clients to connect.\nAllow unknown certificate revocation status when using …\nGet the ALPN protocol identifiers submitted by the client.\nProtocol names we support, most preferred first. If empty …\nBuild a client certificate verifier. The built verifier …\nCreate a builder for the <code>webpki</code> client certificate …\nCreate a builder for a server configuration with the …\nCreate a builder for a server configuration with the …\nCreate a builder for the <code>webpki</code> client certificate …\nCreate a builder for a server configuration with a …\nWhether the store can cache another session. This is used …\nHow to choose a server cert and key. This is usually set by\nGet cipher suites.\nClear the list of trust anchor hint subjects.\nGet the <code>ClientHello</code> for this connection.\nDangerous configuration that should be audited and used …\nExtract secrets, so they can be used when configuring …\nDecrypt <code>cipher</code>, validating its authenticity protection and …\nReturn an empty Acceptor, ready to receive bytes from a …\nReturns an <code>io::Read</code> implementer you can read bytes from …\nAllows traffic secrets to be extracted after the handshake,\nReturns true if this implementation will encrypt/decrypt …\nEncrypt and authenticate <code>plain</code>, returning the resulting …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFind a value with the given <code>key</code>.  Return it, or None if it …\nIgnore the client’s ciphersuite order. Instead, choose …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the <code>Accepted</code> into a <code>ServerConnection</code>.\nHow to output key material for debugging.  The default …\nReturns the lifetime in seconds of tickets produced now. …\nAmount of early data to accept for sessions created by …\nThe maximum size of plaintext input to be emitted in a …\nMake a new ServerSessionMemoryCache.  <code>size</code> is the maximum …\nMake a new ServerConnection.  <code>config</code> controls how we …\nCreate a new and empty (i.e., knows no certificates) …\nCreate a new <code>WebPkiClientVerifier</code> that disables client …\nOnly check the end entity certificate revocation status …\nStore session secrets encoded in <code>value</code> against <code>key</code>, …\nRead TLS content from <code>rd</code>.\nApplication-controlled portion of the resumption ticket …\nExplicitly discard early data, notifying the client\nChoose a certificate chain and matching key given …\nWhether the server should send “0.5RTT” data.  This …\nHow many TLS1.3 tickets to send immediately after a …\nGet the server name indicator.\nRetrieves the server name, if any, used to select the …\nHow to store client sessions.\nSet the resumption data to embed in future resumption …\nGet the compatible signature schemes.\nFind a value with the given <code>key</code>.  Return it and delete it; …\nHow to produce tickets.\nVerify the revocation state of presented client …\nZero-sized marker type representing verification of a …\nSomething that can verify a client certificate chain\nMake a <code>ClientCertVerified</code>\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> to enable the server to request a client …\nReturns <code>true</code> to enable the server to request a client …\nReturns the <code>DistinguishedName</code> subjects that the server …\nReturn the list of SignatureSchemes that this verifier …\nVerify the end-entity certificate <code>end_entity</code> is valid, …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given client …\nA packaged-together certificate chain, matching <code>SigningKey</code> …\nA thing that can sign a message.\nAn abstract signing key.\nWhat kind of key we have.\nThe certificate chain.\nChoose a <code>SignatureScheme</code> from those offered.\nThe end-entity certificate.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe certified key.\nMake a new CertifiedKey, with the given chain and key.\nAn optional OCSP response from the certificate issuer, …\nReveals which scheme will be used when you call …\nSigns <code>message</code> using the selected scheme.\nA ticketer that has a ‘current’ sub-ticketer and a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>TicketSwitcher</code>, which rotates through …\nTLS1.2\nTLS1.3")