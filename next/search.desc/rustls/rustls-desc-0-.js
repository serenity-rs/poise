searchState.loadedDescShard("rustls", 0, "Rustls - a modern TLS library\nA list of all the cipher suites supported by rustls.\nA list of all the key exchange groups supported by rustls.\nA list of all the protocol versions supported by rustls.\nAES with 128-bit keys in Galois counter mode.\nAES with 256-bit keys in Galois counter mode.\nThe <code>AlertDescription</code> TLS protocol enum.  Values in this …\nWe received a fatal alert.  This means the peer is unhappy.\nThe certificate is valid, but the handshake is rejected …\nThe certificate is not correctly encoded.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nA certificate is not correctly signed by the key of its …\nThe CRL had a bad, or unsupported signature from its …\nBulk symmetric encryption scheme used by a cipher suite.\nThe ways in which a certificate revocation list (CRL) can …\nThis type contains a single certificate by value.\nThe ways in which certificate validators can express …\nChacha20 for confidentiality with poly1305 for …\nThe <code>CipherSuite</code> TLS protocol enum.  Values in this enum …\nA client initiates the connection.\nA client connection\nConnection state common to both client and server …\nBuilding a <code>ServerConfig</code> or <code>ClientConfig</code> in a …\nHelper trait to abstract <code>ConfigBuilder</code> over building a …\nA client or server connection.\nInterface shared by client and server connections.\nThe <code>ContentType</code> TLS protocol enum.  Values in this enum …\nThe cipher suite configuration that an application should …\nThe version configuration that an application should use …\nWe couldn’t decrypt a message.  This is invariably fatal.\nThis type combines a <code>SignatureScheme</code> and a signature …\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nThe current time is after the <code>notAfter</code> time in the …\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nThis function doesn’t work until the TLS handshake is …\nAn advertised message was larger then expected.\nThe <code>HandshakeType</code> TLS protocol enum.  Values in this enum …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nThe peer sent us a syntactically incorrect …\nContext was incorrectly attached to a certificate request …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nA peer sent an invalid certificate status type\nAn unknown content type was encountered during message …\nThe CRL contained an invalid CRL number.\nA peer’s DH params could not be decoded\nA message was zero-length when its record kind forbids it.\nA peer sent an unexpected key update request.\nA corrupt TLS message payload that resulted in an error.\nThe peer sent us a TLS message with invalid contents.\nThe certificate is being used for a different purpose than …\nThe CRL contained a revoked certificate with an invalid …\nThe presented SCT(s) were invalid.\nA peer’s server name could not be decoded\nValues of this structure are returned from …\nThe CRL issuer does not specify the cRLSign key usage.\nThis trait represents the ability to do something useful …\n<code>KeyLog</code> implementation that opens a file whose name is …\nA TLS message payload was larger then allowed by the …\nMessage is shorter than the expected length\nMissing data for the named handshake payload value\nA peer did not advertise its supported key exchange groups.\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nKeyLog that does exactly nothing.\nA peer sent an empty list of signature schemes\nThe subject names in an end-entity certificate do not …\nThe current time is before the <code>notBefore</code> time in the …\nAny other error.\nThe CRL is invalid for some other reason.\nA trust anchor, commonly known as a “Root Certificate.”\nThe CRL is not correctly encoded.\nThe set of cases where we failed to make a connection …\nThe peer doesn’t support a protocol version/feature we …\nThe set of cases where we failed to make a connection …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nThis type contains a private key by value.\nThe <code>ProtocolVersion</code> TLS protocol enum.  Values in this …\nA structure that implements <code>std::io::Read</code> for reading …\nThe certificate has been revoked.\nA container for root certificates able to provide a …\nA server waits for a client to connect.\nA server connection\nSide of the connection.\nData specific to the peer’s side (client or server).\nThe <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this …\nThe <code>SignatureScheme</code> TLS protocol enum.  Values in this …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nA cipher suite supported by rustls.\nA key-exchange group supported by rustls.\nA TLS protocol version supported by rustls.\nA concrete, safe ticket creation mechanism.\nA TLS 1.2 cipher suite\nA TLS 1.2 cipher suite supported by rustls.\nA TLS 1.3 cipher suite\nA TLS 1.3 cipher suite supported by rustls.\nTrailing data found for the named handshake payload value\nA peer sent an unexpected message type.\nThe certificate contains an extension marked critical, but …\nThe certificate chain is not issued by a known root …\nAn unknown TLS protocol was encountered during message …\nA peer sent a non-null compression method.\nThe CRL, or a revoked certificate in the CRL, contained an …\nThe CRL is not a v2 X.509 CRL.\nA peer sent an unknown elliptic curve type.\nThe CRL is an unsupported delta CRL, containing only …\nThe CRL is an unsupported indirect CRL, containing revoked …\nA peer sent an unsupported key exchange algorithm.\nThe certificate verifier doesn’t support the given type …\nThe CRL contained a revoked certificate with an …\nConfig builder state where the caller must supply cipher …\nConfig builder state where the caller must supply key …\nConfig builder state where the caller must supply a …\nConfig builder state where the caller must supply TLS …\nA structure that implements <code>std::io::Write</code> for writing …\nAdd a single DER-encoded certificate to the store.\nParse the given DER-encoded certificates and add all that …\nAdds all the given TrustAnchors <code>anchors</code>.  This does not …\nAdds all the given TrustAnchors <code>anchors</code>.  This does not …\nRetrieves the protocol agreed with the peer via ALPN.\nCan a session using suite self resume from suite prev?\nAll defined ciphersuites appear in this module.\nItems for use in a client.\nCommon cipher suite fields.\nCommon cipher suite fields.\nThis function uses <code>io</code> to complete any outstanding IO for …\nThis function uses <code>io</code> to complete any outstanding IO for …\nOur TLS connection\nOur connection\nMake a new, empty <code>RootCertStore</code>.\nThis is a non-standard extension which extends the key …\nDerives key material from the agreed connection secrets.\nDerives key material from the agreed connection secrets.\nHow long the fixed part of the ‘IV’ is.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs an <code>OwnedTrustAnchor</code> from its components.\nGet a mutable reference to the underlying socket\nGet a reference to the underlying socket\nWhich hash function to use with this suite.\nInternal classes which may be useful outside the library. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if there are no certificates.\nReturns true if the connection is currently performing the …\nHow to exchange/agree keys.\nAll defined key exchange groups appear in this module.\nSay how many certificates are in the container.\nLog the given <code>secret</code>.  <code>client_random</code> is provided for …\nThis is the rustls manual.\nThe IANA “TLS Supported Groups” name of the group\nRetrieves the ciphersuite agreed with the peer.\nMakes a new <code>KeyLogFile</code>.  The environment variable is …\nMake the recommended Ticketer.  This produces tickets with …\nMake a new Stream using the Connection <code>conn</code> and …\nMake a new StreamOwned taking the Connection <code>conn</code> and …\nRetrieves the certificate chain used by the peer to …\nTrue if the peer has sent us a close_notify alert.  This is\nHow many plaintext bytes could be obtained via …\nProcesses any new packets read by a previous call to …\nProcesses any new packets read by a previous call to …\nRetrieves the protocol version agreed with the peer.\nObtain plaintext data received from the peer over this TLS …\nRead TLS content from <code>rd</code> into the internal buffer.\nRead TLS content from <code>rd</code>.\nReturns an object that allows reading plaintext.\nReturns an object that allows reading plaintext.\nResolve the set of supported <code>SignatureScheme</code>s from the …\nThe list of roots.\nThe <code>SignatureScheme</code> used to produce the signature.\nQueues a close_notify warning alert to be sent in the next …\nItems for use in a server.\nSets a limit on the internal buffers used to buffer unsent …\nMessage signing interfaces and implementations.\nHow to sign messages for authentication.\nGet the signature.\nThe underlying transport, like a socket\nThe underlying transport, like a socket\nReturn the subject field including its outer SEQUENCE …\nThe cipher suite’s identifier\nHow many bytes could be written by <code>Connection::write_tls</code> …\nReturn true if this suite is usable for a key only …\nAll defined protocol versions appear in this module.\nReturn supported protocol version for the cipher suite.\nThe TLS enumeration naming this version.\nReturns true if the caller should call <code>Connection::read_tls</code>…\nReturns true if the caller should call …\nIndicates whether the secret with label <code>label</code> will be …\nIndicates whether the secret with label <code>label</code> will be …\nSets a custom <code>ResolvesServerCert</code>.\nSet Certificate Transparency logs to use for server …\nChoose a specific set of cipher suites.\nSets a single certificate chain and matching private key …\nSets a single certificate chain and matching private key …\nSets a custom <code>ResolvesClientCert</code>.\nSets a custom <code>ResolvesClientCert</code>.\nChoose how to verify client certificates.\nSet a custom certificate verifier.\nChoose a specific set of key exchange groups.\nDisable client authentication.\nDo not support client auth.\nDo not support client auth.\nUse a specific set of protocol versions.\nChoose how to verify server certificates.\nChoose the default set of cipher suites (…\nChoose the default set of key exchange groups (…\nAccept the default protocol versions: both TLS1.2 and …\nStart side-specific config with defaults for underlying …\nSets a single certificate chain and matching private key …\nSets a single certificate chain and matching private key.  …\nSets a single certificate chain and matching private key …\nSets a single certificate chain, matching private key, OCSP\nSend the plaintext <code>buf</code> to the peer, encrypting and …\nWrites TLS messages to <code>wr</code>.\nWrites TLS messages to <code>wr</code>.\nReturns an object that allows writing plaintext.\nReturns an object that allows writing plaintext.\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nThe TLS1.3 ciphersuite TLS_AES_128_GCM_SHA256\nThe TLS1.3 ciphersuite TLS_AES_256_GCM_SHA384\nThe TLS1.3 ciphersuite TLS_CHACHA20_POLY1305_SHA256\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nHow to do bulk encryption.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe TLS enumeration naming this cipher suite.\nPolicy for enforcing Certificate Transparency.\nCommon configuration for (typically) all connections made …\nThis represents a single TLS client connection.\nState associated with a client connection.\nAn implementer of <code>ClientSessionStore</code> that stores everything\nA trait for the ability to store client session data, so …\nAccessor for dangerous configuration options.\nDisable 1.2 resumption.\nThe server is identified by a DNS name.  The name is sent …\nZero-sized marker type representing verification of a …\nThe provided input could not be parsed because it is not a …\nThe server is identified by an IP address. SNI is not done.\nA trait for the ability to choose a certificate chain and …\nConfiguration for how/when a client is allowed to resume a …\nZero-sized marker type representing verification of a …\nSomething that can verify a server certificate chain, and …\nEncodes ways a client can know the expected name of the …\nSupport 1.2 resumption using session ids only.\nSupport 1.2 resumption using session ids or RFC 5077 …\nWhat mechanisms to support for resuming a TLS 1.2 session.\nA config builder state where the caller needs to supply …\nA config builder state where the caller needs to supply a …\nDefault <code>ServerCertVerifier</code>, see the trait impl for more …\nStub that implements io::Write and dispatches to …\nWhich ALPN protocols we include in our client hello. If …\nMake a <code>HandshakeSignatureValid</code>\nMake a <code>ServerCertVerified</code>\nCreate a builder to build up the client configuration.\nHow many bytes you may send.  Writes will become short …\nThe underlying ClientConfig\nHow to decide what client auth certificate/keys to use.\nAccess configuration options whose use is dangerous and …\nCreate an in-memory session store resumption with up to …\nDisable all use of session resumption.\nReturns an <code>io::Write</code> implementer you can write bytes to to …\nWhether to send data on the first flight (“early data”…\nWhether to send the Server Name Indication (SNI) extension …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn true if any certificates at all are available.\nCreate a new <code>Resumption</code> that stores data for the given …\nRemember a TLS1.3 ticket that might be retrieved later …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns True if the server signalled it will process early …\nHow to output key material for debugging.  The default …\nThis should return the value most recently passed to …\nThe maximum size of TLS message we’ll emit.  If None, we …\nConstructs a new <code>WebPkiVerifier</code>.\nCreate a new policy.\nMake a new ClientConnection.  <code>config</code> controls how we …\nMake a new ClientSessionMemoryCache.  <code>size</code> is the maximum …\nRemove and forget any saved TLS1.2 session for <code>server_name</code>.\nReturns <code>true</code> if Rustls should ask the server to send SCTs.\nReturns <code>true</code> if Rustls should ask the server to send SCTs.\nWith the server-supplied acceptable issuers in …\nHow and when the client can resume a previous session.\nOverrides the default <code>ServerCertVerifier</code> with something …\nRemember what <code>NamedGroup</code> the given server chose.\nRemember a TLS1.2 session.\nUse a custom <code>ClientSessionStore</code> implementation to store …\nReturn the list of SignatureSchemes that this verifier …\nReturn the list of SignatureSchemes that this verifier …\nReturn a TLS1.3 ticket previously provided to …\nConfigure whether TLS 1.2 sessions may be resumed, and by …\nGet the most recently saved TLS1.2 session for <code>server_name</code> …\nReturns the signature verification methods supported by …\nVerify the end-entity certificate <code>end_entity</code> is valid for …\nWill verify the certificate is valid in the following ways:\nVerify that the end-entity certificate <code>end_entity</code> is a …\nVerify that the <code>end_entity</code> has a name or alternative name …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nLow-level TLS message decryption functions.\nLow-level TLS message parsing and encoding functions.\nLow-level TLS record layer functions.\nObjects with this trait can decrypt TLS messages.\nPerform the decryption over the concerned TLS message.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn externally length’d payload\nAn arbitrary, unknown-content, u16-length-prefixed payload\nAn arbitrary, unknown-content, u24-length-prefixed payload\nAn arbitrary, unknown-content, u8-length-prefixed payload\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait for implementing encoding and decoding functionality …\nThe length of the length prefix for a list.\nWrapper over a slice of bytes that allows reading chunks …\nA trait for types that can be encoded and decoded in a …\nUsed to check whether the reader has any content left …\nFunction for encoding itself by appending itself to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvenience function for encoding the implementation into …\nConvenience function for encoding the implementation into …\nCreates a new Reader of the provided <code>bytes</code> slice with the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of bytes that are still able to be read …\nFunction for decoding itself from the provided reader will …\nFunction for wrapping a call to the read function in a …\nFunction for wrapping a call to the read function in a …\nBorrows a slice of all the remaining bytes that appear …\nAttempts to create a new Reader on a sub section of this …\nAttempts to borrow a slice of bytes from the current …\nReturns the cursor position which is also the number of …\nThis deframer works to reconstruct TLS messages from a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if we have messages for the caller to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn any decrypted messages that the deframer has been …\nRead some bytes from <code>rd</code>, and add them to our internal …\nThe <code>AlertLevel</code> TLS protocol enum.  Values in this enum are …\nThe <code>CertificateStatusType</code> TLS protocol enum.  Values in …\nThe <code>ClientCertificateType</code> TLS protocol enum.  Values in …\nThe <code>Compression</code> TLS protocol enum.  Values in this enum …\nThe <code>ECCurveType</code> TLS protocol enum.  Values in this enum …\nThe <code>ECPointFormat</code> TLS protocol enum.  Values in this enum …\nThe <code>ExtensionType</code> TLS protocol enum.  Values in this enum …\nThe <code>HashAlgorithm</code> TLS protocol enum.  Values in this enum …\nThe <code>HeartbeatMessageType</code> TLS protocol enum.  Values in …\nThe <code>HeartbeatMode</code> TLS protocol enum.  Values in this enum …\nThe <code>KeyUpdateRequest</code> TLS protocol enum.  Values in this …\nThe <code>NamedCurve</code> TLS protocol enum.  Values in this enum are …\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nThe <code>PSKKeyExchangeMode</code> TLS protocol enum.  Values in this …\nThe <code>ServerNameType</code> TLS protocol enum.  Values in this enum …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the Message <code>msg</code> and re-fragment it into new messages …\nEnqueue borrowed fragments of (version, typ, payload) which\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSet the maximum fragment size that will be produced.\nOnly supports OCSP\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a basic SNI ServerNameRequest quoting <code>hostname</code>.\nMake a new one with one entry.\nA TLS frame, named TLSPlaintext in the standard.\nMaximum on-wire message size.\nA message with decoded payload\nA TLS frame, named TLSPlaintext in the standard.\nA decrypted TLS frame\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce conversion into a plaintext message.\n<code>MessageError</code> allows callers to distinguish between valid …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResult of decryption.\nRecord layer that tracks decryption and encryption keys.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new record layer with no keys.\nThe decrypted message.\nWhether the peer appears to be getting close to encrypting …\nEphemeral ECDH on secp256r1 (aka NIST-P256)\nEphemeral ECDH on secp384r1 (aka NIST-P384)\nEphemeral ECDH on curve25519 (see RFC7748)\nThis section discusses vulnerabilities in other TLS …\nThis section discusses vulnerabilities and design errors …\nThis section collects together goal-oriented documentation.\nThis section documents rustls itself: what protocol …\nThis section provides rationale for the defaults in rustls.\nRepresents a <code>ClientHello</code> message received through the …\nHandle on a server-side connection before configuration is …\nA <code>ClientCertVerifier</code> that will allow both anonymous and …\nA <code>ClientCertVerifier</code> that will ensure that every client …\nZero-sized marker type representing verification of a …\nSomething that can verify a client certificate chain\nA struct representing the received Client Hello\nA type which encapsulates an owned string that is a …\nTurns off client authentication.\nSomething which never stores sessions.\nwrapper around internal representation of a parsed …\nA trait for the ability to encrypt and decrypt tickets.\nAllows reading of early data in resumed TLS1.3 connections.\nHow to choose a certificate chain and signing key for use …\nSomething that resolves do different cert chains/keys based\nCommon configuration for a set of server sessions.\nThis represents a single TLS server connection.\nState associated with a server connection.\nAn implementer of <code>StoresServerSessions</code> that stores …\nA trait for the ability to store server session data.\nAn unparsed DER encoded Certificate Revocation List (CRL).\nA config builder state where the caller must supply how to …\nCheck if a <code>ClientHello</code> message has been received.\nAdd a new <code>sign::CertifiedKey</code> to be used for the given SNI …\nGet the ALPN protocol identifiers submitted by the client.\nProtocol names we support, most preferred first. If empty …\nMake a <code>ClientCertVerified</code>\nProduce a borrowed <code>DnsNameRef</code> from this owned <code>DnsName</code>.\nWrap this verifier in an <code>Arc</code> and coerce it to …\nWrap this verifier in an <code>Arc</code> and coerce it to …\nConstruct a <code>NoClientAuth</code>, wrap it in an <code>Arc</code> and coerce it …\nCreate builder to build up the server configuration.\nWhether the store can cache another session. This is used …\nHow to choose a server cert and key.\nGet cipher suites.\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturns the Subjects of the client authentication trust …\nGet the <code>ClientHello</code> for this connection.\nDecrypt <code>cipher</code>, validating its authenticity protection and …\nReturn an empty Acceptor, ready to receive bytes from a …\nReturns an <code>io::Read</code> implementer you can read bytes from …\nReturns true if this implementation will encrypt/decrypt …\nEncrypt and authenticate <code>plain</code>, returning the resulting …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFind a value with the given <code>key</code>.  Return it, or None if it …\nIgnore the client’s ciphersuite order. Instead, choose …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the <code>Accepted</code> into a <code>ServerConnection</code>.\nHow to output key material for debugging.  The default …\nReturns the lifetime in seconds of tickets produced now. …\nAmount of early data to accept for sessions created by …\nThe maximum size of TLS message we’ll emit.  If None, we …\nConstruct a new <code>AllowAnyAuthenticatedClient</code>.\nConstruct a new <code>AllowAnyAnonymousOrAuthenticatedClient</code>.\nMake a new ServerSessionMemoryCache.  <code>size</code> is the maximum …\nCreate a new and empty (i.e., knows no certificates) …\nMake a new ServerConnection.  <code>config</code> controls how we …\nReturns <code>true</code> to enable the server to request a client …\nReturns <code>true</code> to enable the server to request a client …\nParse the CRL DER, yielding a <code>webpki::CertRevocationList</code> …\nStore session secrets encoded in <code>value</code> against <code>key</code>, …\nRead TLS content from <code>rd</code>.\nApplication-controlled portion of the resumption ticket …\nExplicitly discard early data, notifying the client\nChoose a certificate chain and matching key given …\nWhether the server should send “0.5RTT” data.  This …\nHow many TLS1.3 tickets to send immediately after a …\nGet the server name indicator.\nRetrieves the server name, if any, used to select the …\nHow to store client sessions.\nSet the resumption data to embed in future resumption …\nGet the compatible signature schemes.\nReturn the list of SignatureSchemes that this verifier …\nReturn the list of SignatureSchemes that this verifier …\nFind a value with the given <code>key</code>.  Return it and delete it; …\nHow to produce tickets.\nValidate the given bytes are a DNS name if they are viewed …\nVerify the end-entity certificate <code>end_entity</code> is valid, …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given client …\nUpdate the verifier to validate client certificates …\nUpdate the verifier to validate client certificates …\nA packaged-together certificate chain, matching <code>SigningKey</code> …\nErrors while signing\nA thing that can sign a message.\nAn abstract signing key.\nWhat kind of key we have.\nParse <code>der</code> as any ECDSA key type, returning the first which …\nParse <code>der</code> as any EdDSA key type, returning the first which …\nParse <code>der</code> as any supported key encoding/type, returning …\nThe certificate chain.\nChoose a <code>SignatureScheme</code> from those offered.\nThe end-entity certificate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe certified key.\nMake a new CertifiedKey, with the given chain and key.\nAn optional OCSP response from the certificate issuer, …\nReveals which scheme will be used when you call <code>sign()</code>.\nAn optional collection of SCTs from CT logs, proving the …\nSigns <code>message</code> using the selected scheme.\nThe set of schemes we support for signatures and that are …\nTLS1.2\nTLS1.3")