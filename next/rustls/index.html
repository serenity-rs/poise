<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rustls - a modern TLS library"><title>rustls - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rustls" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-nightly (e92993dbb 2024-10-18)" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rustls/index.html">rustls</a><span class="version">0.22.4</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#rustls---a-modern-tls-library" title="Rustls - a modern TLS library">Rustls - a modern TLS library</a><ul><li><a href="#current-functionality-with-default-crate-features" title="Current functionality (with default crate features)">Current functionality (with default crate features)</a></li><li><a href="#non-features" title="Non-features">Non-features</a></li><li><a href="#design-overview" title="Design Overview">Design Overview</a></li><li><a href="#getting-started" title="Getting started">Getting started</a></li></ul></li><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#crate-features" title="Crate features">Crate features</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>rustls</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/rustls/lib.rs.html#1-551">source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="rustls---a-modern-tls-library"><a class="doc-anchor" href="#rustls---a-modern-tls-library">§</a>Rustls - a modern TLS library</h2>
<p>Rustls is a TLS library that aims to provide a good level of cryptographic security,
requires no configuration to achieve that security, and provides no unsafe features or
obsolete cryptography by default.</p>
<h3 id="current-functionality-with-default-crate-features"><a class="doc-anchor" href="#current-functionality-with-default-crate-features">§</a>Current functionality (with default crate features)</h3>
<ul>
<li>TLS1.2 and TLS1.3.</li>
<li>ECDSA, Ed25519 or RSA server authentication by clients.</li>
<li>ECDSA, Ed25519 or RSA server authentication by servers.</li>
<li>Forward secrecy using ECDHE; with curve25519, nistp256 or nistp384 curves.</li>
<li>AES128-GCM and AES256-GCM bulk encryption, with safe nonces.</li>
<li>ChaCha20-Poly1305 bulk encryption (<a href="https://tools.ietf.org/html/rfc7905">RFC7905</a>).</li>
<li>ALPN support.</li>
<li>SNI support.</li>
<li>Tunable fragment size to make TLS messages match size of underlying transport.</li>
<li>Optional use of vectored IO to minimise system calls.</li>
<li>TLS1.2 session resumption.</li>
<li>TLS1.2 resumption via tickets (<a href="https://tools.ietf.org/html/rfc5077">RFC5077</a>).</li>
<li>TLS1.3 resumption via tickets or session storage.</li>
<li>TLS1.3 0-RTT data for clients.</li>
<li>TLS1.3 0-RTT data for servers.</li>
<li>Client authentication by clients.</li>
<li>Client authentication by servers.</li>
<li>Extended master secret support (<a href="https://tools.ietf.org/html/rfc7627">RFC7627</a>).</li>
<li>Exporters (<a href="https://tools.ietf.org/html/rfc5705">RFC5705</a>).</li>
<li>OCSP stapling by servers.</li>
</ul>
<h3 id="non-features"><a class="doc-anchor" href="#non-features">§</a>Non-features</h3>
<p>For reasons <a href="manual/index.html" title="mod rustls::manual">explained in the manual</a>,
rustls does not and will not support:</p>
<ul>
<li>SSL1, SSL2, SSL3, TLS1 or TLS1.1.</li>
<li>RC4.</li>
<li>DES or triple DES.</li>
<li>EXPORT ciphersuites.</li>
<li>MAC-then-encrypt ciphersuites.</li>
<li>Ciphersuites without forward secrecy.</li>
<li>Renegotiation.</li>
<li>Kerberos.</li>
<li>TLS 1.2 protocol compression.</li>
<li>Discrete-log Diffie-Hellman.</li>
<li>Automatic protocol version downgrade.</li>
<li>Using CA certificates directly to authenticate a server/client (often called “self-signed
certificates”). <em>Rustls’ default certificate verifier does not support using a trust anchor as
both a CA certificate and an end-entity certificate in order to limit complexity and risk in
path building. While dangerous, all authentication can be turned off if required –
see the <a href="https://github.com/rustls/rustls/blob/992e2364a006b2e84a8cf6a7c3eaf0bdb773c9de/examples/src/bin/tlsclient-mio.rs#L318">example code</a></em>.</li>
</ul>
<p>There are plenty of other libraries that provide these features should you
need them.</p>
<h4 id="platform-support"><a class="doc-anchor" href="#platform-support">§</a>Platform support</h4>
<p>While Rustls itself is platform independent, by default it uses
<a href="https://crates.io/crates/ring"><code>ring</code></a> for implementing the cryptography in
TLS. As a result, rustls only runs on platforms
supported by <code>ring</code>. At the time of writing, this means 32-bit ARM, Aarch64 (64-bit ARM),
x86, x86-64, LoongArch64, 32-bit &amp; 64-bit Little Endian MIPS, 32-bit PowerPC (Big Endian),
64-bit PowerPC (Big and Little Endian), 64-bit RISC-V, and s390x. We do not presently
support WebAssembly.
For more information, see <a href="https://github.com/briansmith/ring/blob/2e8363b433fa3b3962c877d9ed2e9145612f3160/include/ring-core/target.h#L18-L64">the supported <code>ring</code> target platforms</a>.</p>
<p>By providing a custom instance of the <a href="crypto/struct.CryptoProvider.html" title="struct rustls::crypto::CryptoProvider"><code>crypto::CryptoProvider</code></a> struct, you
can replace all cryptography dependencies of rustls.  This is a route to being portable
to a wider set of architectures and environments, or compliance requirements.  See the
<a href="crypto/struct.CryptoProvider.html" title="struct rustls::crypto::CryptoProvider"><code>crypto::CryptoProvider</code></a> documentation for more details.</p>
<p>Specifying <code>default-features = false</code> when depending on rustls will remove the
dependency on <em>ring</em>.</p>
<p>Rustls requires Rust 1.61 or later.</p>
<h3 id="design-overview"><a class="doc-anchor" href="#design-overview">§</a>Design Overview</h3><h4 id="rustls-does-not-take-care-of-network-io"><a class="doc-anchor" href="#rustls-does-not-take-care-of-network-io">§</a>Rustls does not take care of network IO</h4>
<p>It doesn’t make or accept TCP connections, or do DNS, or read or write files.</p>
<p>There’s example client and server code which uses mio to do all needed network
IO.</p>
<h4 id="rustls-provides-encrypted-pipes"><a class="doc-anchor" href="#rustls-provides-encrypted-pipes">§</a>Rustls provides encrypted pipes</h4>
<p>These are the <a href="server/struct.ServerConnection.html" title="struct rustls::server::ServerConnection"><code>ServerConnection</code></a> and <a href="client/struct.ClientConnection.html" title="struct rustls::client::ClientConnection"><code>ClientConnection</code></a> types.  You supply raw TLS traffic
on the left (via the <a href="enum.Connection.html#method.read_tls" title="method rustls::Connection::read_tls"><code>read_tls()</code></a> and <a href="enum.Connection.html#method.read_tls" title="method rustls::Connection::read_tls"><code>write_tls()</code></a> methods) and then read/write the
plaintext on the right:</p>
<div class="example-wrap"><pre class="language-text"><code>         TLS                                   Plaintext
         ===                                   =========
    read_tls()      +-----------------------+      reader() as io::Read
                    |                       |
          +---------&gt;   ClientConnection    +---------&gt;
                    |          or           |
          &lt;---------+   ServerConnection    &lt;---------+
                    |                       |
    write_tls()     +-----------------------+      writer() as io::Write</code></pre></div><h4 id="rustls-takes-care-of-server-certificate-verification"><a class="doc-anchor" href="#rustls-takes-care-of-server-certificate-verification">§</a>Rustls takes care of server certificate verification</h4>
<p>You do not need to provide anything other than a set of root certificates to trust.
Certificate verification cannot be turned off or disabled in the main API.</p>
<h3 id="getting-started"><a class="doc-anchor" href="#getting-started">§</a>Getting started</h3>
<p>This is the minimum you need to do to make a TLS client connection.</p>
<p>First we load some root certificates.  These are used to authenticate the server.
The simplest way is to depend on the <a href="https://crates.io/crates/webpki-roots"><code>webpki_roots</code></a> crate which contains
the Mozilla set of root certificates.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>root_store = rustls::RootCertStore::empty();
root_store.extend(
    webpki_roots::TLS_SERVER_ROOTS
        .iter()
        .cloned()
);</code></pre></div>
<p>Next, we make a <code>ClientConfig</code>.  You’re likely to make one of these per process,
and use it for all connections made by that process.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>config = rustls::ClientConfig::builder()
    .with_root_certificates(root_store)
    .with_no_client_auth();</code></pre></div>
<p>Now we can make a connection.  You need to provide the server’s hostname so we
know what to expect to find in the server’s certificate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rc_config = Arc::new(config);
<span class="kw">let </span>example_com = <span class="string">"example.com"</span>.try_into().unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>client = rustls::ClientConnection::new(rc_config, example_com);</code></pre></div>
<p>Now you should do appropriate IO for the <code>client</code> object.  If <code>client.wants_read()</code> yields
true, you should call <code>client.read_tls()</code> when the underlying connection has data.
Likewise, if <code>client.wants_write()</code> yields true, you should call <code>client.write_tls()</code>
when the underlying connection is able to send data.  You should continue doing this
as long as the connection is valid.</p>
<p>The return types of <code>read_tls()</code> and <code>write_tls()</code> only tell you if the IO worked.  No
parsing or processing of the TLS messages is done.  After each <code>read_tls()</code> you should
therefore call <code>client.process_new_packets()</code> which parses and processes the messages.
Any error returned from <code>process_new_packets</code> is fatal to the connection, and will tell you
why.  For example, if the server’s certificate is expired <code>process_new_packets</code> will
return <code>Err(InvalidCertificate(Expired))</code>.  From this point on,
<code>process_new_packets</code> will not do any new work and will return that error continually.</p>
<p>You can extract newly received data by calling <code>client.reader()</code> (which implements the
<code>io::Read</code> trait).  You can send data to the peer by calling <code>client.writer()</code> (which
implements <code>io::Write</code> trait).  Note that <code>client.writer().write()</code> buffers data you
send if the TLS connection is not yet established: this is useful for writing (say) a
HTTP request, but this is buffered so avoid large amounts of data.</p>
<p>The following code uses a fictional socket IO API for illustration, and does not handle
errors.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>rustls::Connection;

client.writer().write(<span class="string">b"GET / HTTP/1.0\r\n\r\n"</span>).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>socket = connect(<span class="string">"example.com"</span>, <span class="number">443</span>);
<span class="kw">loop </span>{
  <span class="kw">if </span>client.wants_read() &amp;&amp; socket.ready_for_read() {
    client.read_tls(<span class="kw-2">&amp;mut </span>socket).unwrap();
    client.process_new_packets().unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>plaintext = Vec::new();
    client.reader().read_to_end(<span class="kw-2">&amp;mut </span>plaintext).unwrap();
    io::stdout().write(<span class="kw-2">&amp;</span>plaintext).unwrap();
  }

  <span class="kw">if </span>client.wants_write() &amp;&amp; socket.ready_for_write() {
    client.write_tls(<span class="kw-2">&amp;mut </span>socket).unwrap();
  }

  socket.wait_for_something_to_happen();
}</code></pre></div>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p><a href="https://github.com/rustls/rustls/blob/main/examples/src/bin/tlsserver-mio.rs"><code>tlsserver-mio</code></a>
and <a href="https://github.com/rustls/rustls/blob/main/examples/src/bin/tlsclient-mio.rs"><code>tlsclient-mio</code></a>
are full worked examples using <a href="https://docs.rs/mio/latest/mio/"><code>mio</code></a>.</p>
<h2 id="crate-features"><a class="doc-anchor" href="#crate-features">§</a>Crate features</h2>
<p>Here’s a list of what features are exposed by the rustls crate and what
they mean.</p>
<ul>
<li>
<p><code>ring</code> (enabled by default): makes the rustls crate depend on the <em>ring</em> crate, which is
used for cryptography by default. Without this feature, these items must be provided
externally to the core rustls crate: see <a href="crypto/struct.CryptoProvider.html" title="struct rustls::crypto::CryptoProvider"><code>CryptoProvider</code></a>.</p>
</li>
<li>
<p><code>aws_lc_rs</code>: makes the rustls crate depend on the aws-lc-rs crate,
which can be used for cryptography as an alternative to <em>ring</em>.
Use <code>rustls::crypto::aws_lc_rs::default_provider()</code> as a <code>CryptoProvider</code>
when making a <code>ClientConfig</code> or <code>ServerConfig</code> to use aws-lc-rs</p>
<p>Note that aws-lc-rs has additional build-time dependencies like cmake.
See <a href="https://aws.github.io/aws-lc-rs/requirements/index.html">the documentation</a> for details.</p>
</li>
<li>
<p><code>tls12</code> (enabled by default): enable support for TLS version 1.2. Note that, due to the
additive nature of Cargo features and because it is enabled by default, other crates
in your dependency graph could re-enable it for your application. If you want to disable
TLS 1.2 for security reasons, consider explicitly enabling TLS 1.3 only in the config
builder API.</p>
</li>
<li>
<p><code>logging</code> (enabled by default): make the rustls crate depend on the <code>log</code> crate.
rustls outputs interesting protocol-level messages at <code>trace!</code> and <code>debug!</code> level,
and protocol-level errors at <code>warn!</code> and <code>error!</code> level.  The log messages do not
contain secret key data, and so are safe to archive without affecting session security.</p>
</li>
<li>
<p><code>read_buf</code>: when building with Rust Nightly, adds support for the unstable
<code>std::io::ReadBuf</code> and related APIs. This reduces costs from initializing
buffers. Will do nothing on non-Nightly releases.</p>
</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.ClientConfig"><code>pub use client::<a class="struct" href="client/struct.ClientConfig.html" title="struct rustls::client::ClientConfig">ClientConfig</a>;</code></div></li><li><div class="item-name" id="reexport.ClientConnection"><code>pub use client::<a class="struct" href="client/struct.ClientConnection.html" title="struct rustls::client::ClientConnection">ClientConnection</a>;</code></div></li><li><div class="item-name" id="reexport.ServerConfig"><code>pub use server::<a class="struct" href="server/struct.ServerConfig.html" title="struct rustls::server::ServerConfig">ServerConfig</a>;</code></div></li><li><div class="item-name" id="reexport.ServerConnection"><code>pub use server::<a class="struct" href="server/struct.ServerConnection.html" title="struct rustls::server::ServerConnection">ServerConnection</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="client/index.html" title="mod rustls::client">client</a></div><div class="desc docblock-short">Items for use in a client.</div></li><li><div class="item-name"><a class="mod" href="crypto/index.html" title="mod rustls::crypto">crypto</a></div><div class="desc docblock-short">Crypto provider interface.</div></li><li><div class="item-name"><a class="mod" href="internal/index.html" title="mod rustls::internal">internal</a></div><div class="desc docblock-short">Internal classes that are used in integration tests.
The contents of this section DO NOT form part of the stable interface.</div></li><li><div class="item-name"><a class="mod" href="manual/index.html" title="mod rustls::manual">manual</a></div><div class="desc docblock-short">This is the rustls manual.</div></li><li><div class="item-name"><a class="mod" href="pki_types/index.html" title="mod rustls::pki_types">pki_<wbr>types</a></div><div class="desc docblock-short">Re-exports the contents of the <a href="https://docs.rs/rustls-pki-types">rustls-pki-types</a> crate for easy access</div></li><li><div class="item-name"><a class="mod" href="quic/index.html" title="mod rustls::quic">quic</a></div><div class="desc docblock-short">APIs for implementing QUIC TLS</div></li><li><div class="item-name"><a class="mod" href="server/index.html" title="mod rustls::server">server</a></div><div class="desc docblock-short">Items for use in a server.</div></li><li><div class="item-name"><a class="mod" href="sign/index.html" title="mod rustls::sign">sign</a></div><div class="desc docblock-short">Message signing interfaces.</div></li><li><div class="item-name"><a class="mod" href="ticketer/index.html" title="mod rustls::ticketer">ticketer</a></div><div class="desc docblock-short">APIs for implementing TLS tickets</div></li><li><div class="item-name"><a class="mod" href="version/index.html" title="mod rustls::version">version</a></div><div class="desc docblock-short">All defined protocol versions appear in this module.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CommonState.html" title="struct rustls::CommonState">Common<wbr>State</a></div><div class="desc docblock-short">Connection state common to both client and server connections.</div></li><li><div class="item-name"><a class="struct" href="struct.ConfigBuilder.html" title="struct rustls::ConfigBuilder">Config<wbr>Builder</a></div><div class="desc docblock-short">A <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder</a> for <a href="server/struct.ServerConfig.html" title="struct rustls::server::ServerConfig"><code>ServerConfig</code></a> or <a href="client/struct.ClientConfig.html" title="struct rustls::client::ClientConfig"><code>ClientConfig</code></a> values.</div></li><li><div class="item-name"><a class="struct" href="struct.ConnectionCommon.html" title="struct rustls::ConnectionCommon">Connection<wbr>Common</a></div><div class="desc docblock-short">Interface shared by client and server connections.</div></li><li><div class="item-name"><a class="struct" href="struct.DigitallySignedStruct.html" title="struct rustls::DigitallySignedStruct">Digitally<wbr>Signed<wbr>Struct</a></div><div class="desc docblock-short">This type combines a <a href="enum.SignatureScheme.html" title="enum rustls::SignatureScheme"><code>SignatureScheme</code></a> and a signature payload produced with that scheme.</div></li><li><div class="item-name"><a class="struct" href="struct.DistinguishedName.html" title="struct rustls::DistinguishedName">Distinguished<wbr>Name</a></div><div class="desc docblock-short">A <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.</div></li><li><div class="item-name"><a class="struct" href="struct.ExtractedSecrets.html" title="struct rustls::ExtractedSecrets">Extracted<wbr>Secrets</a></div><div class="desc docblock-short">Secrets for transmitting/receiving data over a TLS session.</div></li><li><div class="item-name"><a class="struct" href="struct.IoState.html" title="struct rustls::IoState">IoState</a></div><div class="desc docblock-short">Values of this structure are returned from <a href="enum.Connection.html#method.process_new_packets" title="method rustls::Connection::process_new_packets"><code>Connection::process_new_packets</code></a>
and tell the caller the current I/O state of the TLS connection.</div></li><li><div class="item-name"><a class="struct" href="struct.KeyLogFile.html" title="struct rustls::KeyLogFile">KeyLog<wbr>File</a></div><div class="desc docblock-short"><a href="trait.KeyLog.html" title="trait rustls::KeyLog"><code>KeyLog</code></a> implementation that opens a file whose name is
given by the <code>SSLKEYLOGFILE</code> environment variable, and writes
keys into it.</div></li><li><div class="item-name"><a class="struct" href="struct.NoKeyLog.html" title="struct rustls::NoKeyLog">NoKey<wbr>Log</a></div><div class="desc docblock-short">KeyLog that does exactly nothing.</div></li><li><div class="item-name"><a class="struct" href="struct.OtherError.html" title="struct rustls::OtherError">Other<wbr>Error</a></div><div class="desc docblock-short">Any other error that cannot be expressed by a more specific <a href="enum.Error.html" title="enum rustls::Error"><code>Error</code></a> variant.</div></li><li><div class="item-name"><a class="struct" href="struct.Reader.html" title="struct rustls::Reader">Reader</a></div><div class="desc docblock-short">A structure that implements <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read"><code>std::io::Read</code></a> for reading plaintext.</div></li><li><div class="item-name"><a class="struct" href="struct.RootCertStore.html" title="struct rustls::RootCertStore">Root<wbr>Cert<wbr>Store</a></div><div class="desc docblock-short">A container for root certificates able to provide a root-of-trust
for connection authentication.</div></li><li><div class="item-name"><a class="struct" href="struct.Stream.html" title="struct rustls::Stream">Stream</a></div><div class="desc docblock-short">This type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating
a Connection <code>C</code> and an underlying transport <code>T</code>, such as a socket.</div></li><li><div class="item-name"><a class="struct" href="struct.StreamOwned.html" title="struct rustls::StreamOwned">Stream<wbr>Owned</a></div><div class="desc docblock-short">This type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating
and owning a Connection <code>C</code> and an underlying blocking transport
<code>T</code>, such as a socket.</div></li><li><div class="item-name"><a class="struct" href="struct.SupportedProtocolVersion.html" title="struct rustls::SupportedProtocolVersion">Supported<wbr>Protocol<wbr>Version</a></div><div class="desc docblock-short">A TLS protocol version supported by rustls.</div></li><li><div class="item-name"><a class="struct" href="struct.Tls12CipherSuite.html" title="struct rustls::Tls12CipherSuite">Tls12<wbr>Cipher<wbr>Suite</a></div><div class="desc docblock-short">A TLS 1.2 cipher suite supported by rustls.</div></li><li><div class="item-name"><a class="struct" href="struct.Tls13CipherSuite.html" title="struct rustls::Tls13CipherSuite">Tls13<wbr>Cipher<wbr>Suite</a></div><div class="desc docblock-short">A TLS 1.3 cipher suite supported by rustls.</div></li><li><div class="item-name"><a class="struct" href="struct.WantsVerifier.html" title="struct rustls::WantsVerifier">Wants<wbr>Verifier</a></div><div class="desc docblock-short">Config builder state where the caller must supply a verifier.</div></li><li><div class="item-name"><a class="struct" href="struct.WantsVersions.html" title="struct rustls::WantsVersions">Wants<wbr>Versions</a></div><div class="desc docblock-short">Config builder state where the caller must supply TLS protocol versions.</div></li><li><div class="item-name"><a class="struct" href="struct.Writer.html" title="struct rustls::Writer">Writer</a></div><div class="desc docblock-short">A structure that implements <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write"><code>std::io::Write</code></a> for writing plaintext.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AlertDescription.html" title="enum rustls::AlertDescription">Alert<wbr>Description</a></div><div class="desc docblock-short">The <code>AlertDescription</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.CertRevocationListError.html" title="enum rustls::CertRevocationListError">Cert<wbr>Revocation<wbr>List<wbr>Error</a></div><div class="desc docblock-short">The ways in which a certificate revocation list (CRL) can be invalid.</div></li><li><div class="item-name"><a class="enum" href="enum.CertificateError.html" title="enum rustls::CertificateError">Certificate<wbr>Error</a></div><div class="desc docblock-short">The ways in which certificate validators can express errors.</div></li><li><div class="item-name"><a class="enum" href="enum.CipherSuite.html" title="enum rustls::CipherSuite">Cipher<wbr>Suite</a></div><div class="desc docblock-short">The <code>CipherSuite</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.Connection.html" title="enum rustls::Connection">Connection</a></div><div class="desc docblock-short">A client or server connection.</div></li><li><div class="item-name"><a class="enum" href="enum.ConnectionTrafficSecrets.html" title="enum rustls::ConnectionTrafficSecrets">Connection<wbr>Traffic<wbr>Secrets</a></div><div class="desc docblock-short">Secrets used to encrypt/decrypt data in a TLS session.</div></li><li><div class="item-name"><a class="enum" href="enum.ContentType.html" title="enum rustls::ContentType">Content<wbr>Type</a></div><div class="desc docblock-short">The <code>ContentType</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum rustls::Error">Error</a></div><div class="desc docblock-short">rustls reports protocol errors using this type.</div></li><li><div class="item-name"><a class="enum" href="enum.HandshakeType.html" title="enum rustls::HandshakeType">Handshake<wbr>Type</a></div><div class="desc docblock-short">The <code>HandshakeType</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.InvalidMessage.html" title="enum rustls::InvalidMessage">Invalid<wbr>Message</a></div><div class="desc docblock-short">A corrupt TLS message payload that resulted in an error.</div></li><li><div class="item-name"><a class="enum" href="enum.NamedGroup.html" title="enum rustls::NamedGroup">Named<wbr>Group</a></div><div class="desc docblock-short">The <code>NamedGroup</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.PeerIncompatible.html" title="enum rustls::PeerIncompatible">Peer<wbr>Incompatible</a></div><div class="desc docblock-short">The set of cases where we failed to make a connection because a peer
doesn’t support a TLS version/feature we require.</div></li><li><div class="item-name"><a class="enum" href="enum.PeerMisbehaved.html" title="enum rustls::PeerMisbehaved">Peer<wbr>Misbehaved</a></div><div class="desc docblock-short">The set of cases where we failed to make a connection because we thought
the peer was misbehaving.</div></li><li><div class="item-name"><a class="enum" href="enum.ProtocolVersion.html" title="enum rustls::ProtocolVersion">Protocol<wbr>Version</a></div><div class="desc docblock-short">The <code>ProtocolVersion</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.Side.html" title="enum rustls::Side">Side</a></div><div class="desc docblock-short">Side of the connection.</div></li><li><div class="item-name"><a class="enum" href="enum.SignatureAlgorithm.html" title="enum rustls::SignatureAlgorithm">Signature<wbr>Algorithm</a></div><div class="desc docblock-short">The <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.SignatureScheme.html" title="enum rustls::SignatureScheme">Signature<wbr>Scheme</a></div><div class="desc docblock-short">The <code>SignatureScheme</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></li><li><div class="item-name"><a class="enum" href="enum.SupportedCipherSuite.html" title="enum rustls::SupportedCipherSuite">Supported<wbr>Cipher<wbr>Suite</a></div><div class="desc docblock-short">A cipher suite supported by rustls.</div></li></ul><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="static" href="static.ALL_VERSIONS.html" title="static rustls::ALL_VERSIONS">ALL_<wbr>VERSIONS</a></div><div class="desc docblock-short">A list of all the protocol versions supported by rustls.</div></li><li><div class="item-name"><a class="static" href="static.DEFAULT_VERSIONS.html" title="static rustls::DEFAULT_VERSIONS">DEFAULT_<wbr>VERSIONS</a></div><div class="desc docblock-short">The version configuration that an application should use by default.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ConfigSide.html" title="trait rustls::ConfigSide">Config<wbr>Side</a></div><div class="desc docblock-short">Helper trait to abstract <a href="struct.ConfigBuilder.html" title="struct rustls::ConfigBuilder"><code>ConfigBuilder</code></a> over building a <a href="client/struct.ClientConfig.html" title="struct rustls::client::ClientConfig"><code>ClientConfig</code></a> or <a href="server/struct.ServerConfig.html" title="struct rustls::server::ServerConfig"><code>ServerConfig</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.KeyLog.html" title="trait rustls::KeyLog">KeyLog</a></div><div class="desc docblock-short">This trait represents the ability to do something useful
with key material, such as logging it to a file for debugging.</div></li><li><div class="item-name"><a class="trait" href="trait.SideData.html" title="trait rustls::SideData">Side<wbr>Data</a></div><div class="desc docblock-short">Data specific to the peer’s side (client or server).</div></li></ul></section></div></main></body></html>